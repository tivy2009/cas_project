# 定时拉取配置
#init_worker_by_lua_block {
#    local handle = nil;

#    handle = function ()
#        --TODO:控制每次只有一个worker执行
#        ngx.log(ngx.INFO, "current :=============");
#        ngx.timer.at(30, handle);
#    end
#    ngx.timer.at(30, handle);
#}

lua_shared_dict _ups_zone 64m; # 定义upstream共享内存空间

upstream redis_cluster {
	server 127.0.0.1:6379;
}

init_worker_by_lua_file /usr/local/nginx/conf/cus_conf/split.lua;

server {
        listen 9090;
        location = /redis {
            internal;
            set_unescape_uri $key $arg_key;
            redis2_query get $key;
            redis2_pass redis_cluster;
        }

        location / {
            set $target '';            
            access_by_lua '
        	local parameters = split_path(ngx.var.uri)
        	local action = parameters[1]

        	if(#parameters == 0) then
                  	 ngx.exit(ngx.HTTP_FORBIDDEN)
        	end
        
                ngx.log(ngx.ERR,"uri action: ",action)

        	local key = action
        	local res = ngx.location.capture(
                    	"/redis", { args = { key = key } }
        	)

        	if res.status ~= 200 then
                   	ngx.log(ngx.ERR, "redis server returned bad status: ",res.status)
                    	ngx.exit(res.status)
        	end

        	if not res.body then
                    	ngx.log(ngx.ERR, "redis returned empty body")
                    	ngx.exit(500)
        	end

        	local parser = require "redis.parser"
        	local server, typ = parser.parse_reply(res.body)
		ngx.log(ngx.ERR,"server:",server,", typ:",typ)
        	if typ ~= parser.BULK_REPLY or not server then
                    	ngx.log(ngx.ERR, "bad redis response: ", res.body)
                    	ngx.exit(500)
        	end

        	if server == "" then
                    	server = "default.com"
       		end

		local cjson = require("cjson")
		local serverobj = cjson.decode(server)

                local dyups = require "ngx.dyups"
                --local status, rv = dyups.update(key,[[server 127.0.0.1:80;server 10.0.2.119:80;]])
                local status, rv = dyups.update(key,[[serverobj.upstream]])

		ngx.log(ngx.ERR,"status:",status,", rv:",rv)
		if status ~= ngx.HTTP_OK then
	                ngx.log(ngx.ERR,"status:",status,", rv:",rv)
			return
		end
		ngx.log(ngx.ERR,"update upstream success")
		ngx.var.target = key

        	--server = server .. "/api/" .. action
        	--if ngx.var.QUERY_STRING ~= nil and ngx.var.QUERY_STRING ~= "" then
                --		server = server .."&"..ngx.var.QUERY_STRING
        	--end

        	--ngx.var.target = server        
       	     ';
          #resolver 8.8.8.8;               
          proxy_pass http://$target/;
     }
}

server {
	listen 9091;

        # GET /get?key=some_key
	location = /get {
		set_unescape_uri $key $arg_key;  # this requires ngx_set_misc
		redis2_query get $key;
		redis2_pass redis_cluster;
	}

        # GET /set?key=one&val=first%20value
	location = /set {
	       set_unescape_uri $key $arg_key;  # this requires ngx_set_misc
	       set_unescape_uri $val $arg_val;  # this requires ngx_set_misc
	       redis2_query set $key $val;
	       redis2_pass redis_cluster;
	}

	location = /redis {
		set_unescape_uri $query $arg_query;
		redis2_query $query;
		redis2_pass $arg_backend;
	}

	location = /foo {
		content_by_lua '
			local res = ngx.location.capture("/redis",
					{ args = {
					          query="one",
				                  backend="redis_cluster"
				                 }
					}
				)
			ngx.say(res.body)
			';
	}
}

upstream qq_backend {
	server 14.17.42.40;
	server 14.17.32.211;
	server 59.37.96.63;
}

server {
	listen   8081;
	location / {
		dyups_interface;
	}
}

server {
	listen   8082;
	location / {
                # The upstream here must be a nginx variable
		proxy_pass http://$host; 
	}
}

server {
	listen      8080;
	access_log  off;

        # 更新 upstream API 接口
	location = /ups_update {
		content_by_lua '
			local ups = ngx.req.get_uri_args()["ups"]
			if ups == nil then
				ngx.say("usage: /ups_update?ups=x.x.x.x")
				return
			end
			local host = ngx.var.http_host
			local ups_from = ngx.shared._ups_zone:get(host);
			ngx.log(ngx.WARN, host, " update upstream from ", ups_from, " to ", ups)
			ngx.shared._ups_zone:set(host, ups);
			ngx.say(host, " update upstream from ", ups_from, " to ", ups)
		';
	}

	location / {
               # 动态设置当前 upstream, 未设置则使用默认 upstream
		set_by_lua $cur_ups '
			local ups = ngx.shared._ups_zone:get(ngx.var.http_host)
			if ups ~= nil then
				ngx.log(ngx.ERR, "get [", ups, "] from ngx.shared._ups_zone")
				return ups
			end
			--ngx.log(ngx.INFO, "use default upstream");
	        	return "qq_backend";
		'
		proxy_next_upstream off;
		proxy_set_header    Host $host;
		proxy_http_version  1.1;
		proxy_set_header    Connection  "";
		proxy_pass $scheme://$cur_ups;
	}
}
